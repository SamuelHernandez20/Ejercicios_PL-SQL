 ¿Qué son los disparadores compuestos o COMPOUND TRIGGERS?

- Los Disparadores Compuestos o Compound Triggers, son una nueva herramienta para apoyar en la codificación reducida y la interactividad entre objetos en base de datos.

¿Cuáles son las cada una de sus secciones?

1. BEFORE STATEMENT y AFTER STATEMENT:

- Estas secciones se ejecutan una sola vez, antes o después de todas las operaciones DML (INSERT, UPDATE, DELETE).

¿Cuándo Usar?:

- BEFORE STATEMENT: Para inicializar variables o realizar acciones que deben ejecutarse una vez antes de que se procesen todas las filas afectadas por la transacción.
- AFTER STATEMENT: Para realizar acciones después de que todas las filas han sido procesadas, como registrar una acción de auditoría o realizar limpieza.

2. BEFORE EACH ROW y AFTER EACH ROW:

- Estas secciones se ejecutan una vez para cada fila afectada por la operación DML.

¿Cuándo Usar?:

BEFORE EACH ROW: Para preparar o modificar datos antes de que se realicen las operaciones en la base de datos. Ideal para validar o modificar valores de una fila antes de que se inserten o actualicen en la tabla.
AFTER EACH ROW: Para realizar acciones después de que se ha procesado cada fila, como registrar cambios en una tabla de auditoría para cada fila afectada.


-----------------------------
Ejercicios de introducción:
-----------------------------

-- 1 

CREATE OR REPLACE TRIGGER trig1_before_st BEFORE
 INSERT OR UPDATE OR DELETE ON emp
 BEGIN
 dbms_output.put_line('BEFORE STATEMENT TRIGGER');
 END;
/
CREATE OR REPLACE TRIGGER trig1_before_rw BEFORE
 INSERT OR UPDATE OR DELETE ON emp
 FOR EACH ROW
 BEGIN
 dbms_output.put_line('BEFORE ROW TRIGGER');
 END;
/
CREATE OR REPLACE TRIGGER trig2_after_st AFTER
 INSERT OR UPDATE OR DELETE ON emp
 BEGIN
 dbms_output.put_line('BEFORE STATEMENT TRIGGER');
 END;
/
CREATE OR REPLACE TRIGGER trig2_after_rw AFTER
 INSERT OR UPDATE OR DELETE ON emp
 FOR EACH ROW
 BEGIN
 dbms_output.put_line('AFTER ROW TRIGGER');
 END;

-- Activación del trigger:

 insert into emp values (1,'Samuel',1000,102);


-- 2 Los 4 tipos de triggers anteriores se pueden combinar en un solo trigger:


CREATE OR REPLACE TRIGGER EMP_COMP_TRIGGER
FOR INSERT OR UPDATE OR DELETE ON emp COMPOUND TRIGGER

-- Variables globales
variable_global VARCHAR2(50):= ' DEMO ON COMPOUND TRIGGER ';

BEFORE STATEMENT IS
-- Variables de declaración
l_variable VARCHAR2(50) := ' BEFORE STATEMENT TRIGGER ';
BEGIN
-- Acciones BEFORE STATEMENT
dbms_output.put_line(l_variable||variable_global);
END BEFORE STATEMENT;


BEFORE EACH ROW IS
-- Variables de declaración
l_variable VARCHAR2(50) := ' BEFORE EACH ROW TRIGGER ';
BEGIN
-- Acciones BEFORE EACH ROW
dbms_output.put_line(l_variable||variable_global);
END BEFORE EACH ROW;


AFTER EACH ROW IS
-- Variables de declaración
l_variable VARCHAR2(50) := ' AFTER EACH ROW TRIGGER ';
BEGIN
-- Acciones AFTER EACH
dbms_output.put_line(l_variable||variable_global);
END AFTER EACH ROW;


AFTER STATEMENT IS
-- Variables de declaración
l_variable VARCHAR2(50) := ' AFTER STATEMENT TRIGGER ';
BEGIN
-- After statement section
dbms_output.put_line(l_variable||variable_global);
END AFTER STATEMENT;

END emp_comp_trigger;
/

-- Activación del trigger:

update emp
set salario = salario + 1000
where empleado_id = 1;
where empleado_id = 1;


-- 3 Se pueden especificar los 3 tipos de operaciones (INSERTING, UPDATING, DELETING).

CREATE OR REPLACE TRIGGER EMP_COMP_TRIGGER
FOR INSERT OR UPDATE OR DELETE ON emp COMPOUND TRIGGER

-- Variables globales
variable_global VARCHAR2(50):= ' DEMO ON COMPOUND TRIGGER ';

BEFORE STATEMENT IS
l_variable VARCHAR2(50) := ' BEFORE STATEMENT ';
BEGIN

IF INSERTING THEN
dbms_output.put_line(l_variable || variable_global || ' INSERT');

ELSIF UPDATING THEN
dbms_output.put_line(l_variable || variable_global || ' UPDATE');

ELSIF DELETING THEN
dbms_output.put_line(l_variable || variable_global || ' DELETE');

END IF;
END BEFORE STATEMENT;

END emp_comp_trigger;
/

-- Activación del trigger:

insert into emp values (5,'Manolo',1000,102);

update emp
set salario = salario + 1000
where empleado_id = 1;
where empleado_id = 1;

delete from emp
where empleado_id = 5;

-- 4 Capturar previamente mediante un "BEFORE" cada una de las 3 operaciones de insercción, actualización o borrado, y registrarlas despues fila por fila con un "AFTER", en una tabla que 
     audite dicha información:

CREATE SEQUENCE auditoria_empleados_acciones
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

CREATE TABLE Auditoria_Empleados_Acciones (
    AuditID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    EmpID NUMBER,
    Accion VARCHAR2(10),
    Fecha TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE OR REPLACE TRIGGER trg_AuditoriaEmpleados
COMPOUND TRIGGER

    -- Sección de declaración de variables:

    v_empid Empleados.EmpID%TYPE;
    v_accion VARCHAR2(10);

    -- Acción a realizar antes de la inserción:

    BEFORE INSERT ON Empleados
    FOR EACH ROW
    BEGIN
        v_empid := :NEW.EmpID;
        v_accion := 'INSERT';
    END BEFORE INSERT;

    -- Acción a realizar antes de la actualización:

    BEFORE UPDATE ON Empleados
    FOR EACH ROW
    BEGIN
        v_empid := :NEW.EmpID;
        v_accion := 'UPDATE';
    END BEFORE UPDATE;

    -- Acción a realizar antes de la eliminación:

    BEFORE DELETE ON Empleados
    FOR EACH ROW
    BEGIN
        v_empid := :OLD.EmpID;
        v_accion := 'DELETE';
    END BEFORE DELETE;

    -- Acción a realizar después de todas las operaciones:

    AFTER EACH ROW
    BEGIN
        INSERT INTO Auditoria_Empleados_Acciones (EmpID, Accion)
        VALUES (v_empid, v_accion);
    END AFTER EACH ROW;

END trg_AuditoriaEmpleados;

-- 5 Trigger compuesto que se active al realizar operaciones de inserción, actualización o borrado sobre la tabla 'cli' y auditar en 'AuditoriaClientes' información
-- correspondiente a cada cliente en función de si se inserta, actualiza o borra. Hacer uso del condicional 'IF', y sentencia 'INSERT INTO' para cada caso.

CREATE TABLE Cli (
    ClienteID NUMBER PRIMARY KEY,
    Nombre VARCHAR2(100),
    Direccion VARCHAR2(255)
);

CREATE TABLE AuditoriaClientes (
    AuditoriaID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ClienteID NUMBER,
    Nombre VARCHAR2(100),
    Direccion VARCHAR2(255),
    Accion VARCHAR2(10),
    Fecha TIMESTAMP
);
/

CREATE SEQUENCE auditoria_CLI
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;
/

CREATE OR REPLACE TRIGGER CLI_COMP_TRIGGER
FOR INSERT OR UPDATE OR DELETE ON cli COMPOUND TRIGGER

  -- Variable global
  v_fecha TIMESTAMP;

  -- Sección BEFORE STATEMENT
  BEFORE STATEMENT IS
  BEGIN
    v_fecha := SYSDATE;
  END BEFORE STATEMENT;

  -- Sección BEFORE EACH ROW
  BEFORE EACH ROW IS
  l_variable VARCHAR2(50) := 'Procesando fila de la tabla Clientes...';
  BEGIN
    -- Esta sección está vacía en este caso, pero debe estar correctamente delimitada
    dbms_output.put_line('-' || l_variable);
  END BEFORE EACH ROW;

  -- Sección AFTER EACH ROW
  AFTER EACH ROW IS
  BEGIN
    IF INSERTING THEN
      INSERT INTO AuditoriaClientes (AuditoriaID, ClienteID, Nombre, Direccion, Accion, Fecha)
      VALUES (auditoria_CLI.NEXTVAL, :NEW.ClienteID, :NEW.Nombre, :NEW.Direccion, 'INSERT', v_fecha);

    ELSIF UPDATING THEN
      INSERT INTO AuditoriaClientes (AuditoriaID, ClienteID, Nombre, Direccion, Accion, Fecha)
      VALUES (auditoria_CLI.NEXTVAL, :NEW.ClienteID, :NEW.Nombre, :NEW.Direccion, 'UPDATE', v_fecha);

    ELSIF DELETING THEN
      INSERT INTO AuditoriaClientes (AuditoriaID, ClienteID, Nombre, Direccion, Accion, Fecha)
      VALUES (auditoria_CLI.NEXTVAL, :OLD.ClienteID, :OLD.Nombre, :OLD.Direccion, 'DELETE', v_fecha);
    END IF;
  END AFTER EACH ROW;

END CLI_COMP_TRIGGER;
/

-- Activación del Trigger:

INSERT INTO ClI(ClienteID, Nombre, Direccion) VALUES (13, 'Manuel', 'Calle Nicaragua, Madrid');

-- Comprobación dela auditación:

select * from AuditoriaClientes;

-- Creación de un Trigger compuesto para la sincronización de datos entre 2 tablas; 'Emps' y 'Deps' (Empleados y Departamentos). 
-- Usando las sección 'BEFORE EACH ROW' para capturar el 'DepartamentoID' antiguo y nuevo, y la sección 'AFTER EACH ROW' para las operaciones que detallo a continuación: 

-- Haciendo uso del condicional 'IF': 
-- En la primera condición de inserción actualizar la tabla 'Deps', incrementando en 1 el campo 'NumeroEmpleados' del nuevo departamento insertado.
-- En la segunda condición de actualización, hacer uso de 2 updates, el primero para decrementar en 1 el campo 'NumeroEmpleados' de la tabla 'Deps' del antiguo departamento, y el segundo para incrementarlo en el nuevo 
  departamento.
-- En la ultima condición de borrado, actualizar la tabla 'Deps', para decrementar en 1 el campo 'NumeroEmpleados' de la tabla 'Deps' del antiguo departamento al que pertenecía.

 CREATE OR REPLACE TRIGGER Emps_Deps_sincronización_COMP_TRIGGER
FOR INSERT OR UPDATE OR DELETE ON Emps COMPOUND TRIGGER

  BEFORE EACH ROW IS
  v_departamentoId_antiguo Emps.DepartamentoID%TYPE;
  v_departamentoId_nuevo   Emps.DepartamentoID%TYPE;
  
  BEGIN
    v_departamentoId_antiguo := :old.DepartamentoID;
    v_departamentoId_nuevo := :new.DepartamentoID;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS

  BEGIN
    IF INSERTING THEN
    
    update Deps
    set NumeroEmpleados = NumeroEmpleados + 1
    where DepartamentoID = :NEW.DepartamentoID;

    ELSIF UPDATING THEN
      
    update Deps
    set NumeroEmpleados = NumeroEmpleados - 1
    where DepartamentoID = :OLD.DepartamentoID;
    
    update Deps
    set NumeroEmpleados = NumeroEmpleados + 1
    where DepartamentoID = :NEW.DepartamentoID;


    ELSIF DELETING THEN
    
    update Deps
    set NumeroEmpleados = NumeroEmpleados - 1
    where DepartamentoID = :OLD.DepartamentoID;
    
    END IF;
  END AFTER EACH ROW;

END Emps_Deps_sincronización_COMP_TRIGGER;
/

-- Activación del Trigger:

-- Inserción:

INSERT INTO  Emps (EmpleadoID,Nombre,DepartamentoID,FechaContratacion) VALUES (104, 'Samuel Hernández', 1, '15/08/24');

-- Actualización:

update Emps 
set DepartamentoID = 2
where EmpleadoID = 104;

-- Borrado:

delete Emps
where EmpleadoID = 104;


-- 6 Ejercicio: Gestión Avanzada de Estados de Proceso con Compound Trigger


CREATE SEQUENCE Historial_Tareas_seq
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;
/


CREATE TABLE Tareas (
    TareaID NUMBER PRIMARY KEY,
    Descripcion VARCHAR2(255),
    Estado VARCHAR2(20), -- Puede ser 'Pendiente', 'En Progreso', o 'Completado'
    FechaCreacion DATE,
    FechaFinalizacion DATE,
    ResponsableID NUMBER, -- Referencia a la tabla Usuarios
    ProyectoID NUMBER -- Referencia a la tabla Proyectos
);


CREATE TABLE Proyectos (
    ProyectoID NUMBER PRIMARY KEY,
    Nombre VARCHAR2(255),
    EstadoGlobal VARCHAR2(20) -- Puede ser 'Pendiente', 'En Progreso', o 'Completado'
);

CREATE TABLE HistorialTareas (
    HistorialID NUMBER PRIMARY KEY,
    TareaID NUMBER,
    EstadoAnterior VARCHAR2(20),
    EstadoNuevo VARCHAR2(20),
    FechaCambio TIMESTAMP,
    Usuario VARCHAR2(50) -- Asume que tienes una manera de registrar el usuario que realizó el cambio
);




-- Trigger Compuesto:

create or replace TRIGGER Estado_tareas_COMP_TRIGGER
FOR UPDATE OF estado ON Tareas COMPOUND TRIGGER

  v_identificador_tarea Tareas.tareaid%TYPE;
  v_identificador_responsable Tareas.responsableid%TYPE;
  v_estado_antiguo_tarea Tareas.estado%TYPE;
  v_estado_nuevo_tarea   Tareas.estado%TYPE;
  v_fecha_finalizacion_antigua Tareas.fechafinalizacion%TYPE;
  v_identificador_proyecto_tarea Tareas.proyectoid%TYPE;
  v_nombre_usuario VARCHAR2(8);
  v_fecha_cambio TIMESTAMP;

  BEFORE EACH ROW IS
  BEGIN
    v_estado_antiguo_tarea := :old.estado;
    v_estado_nuevo_tarea := :new.estado;
    v_identificador_responsable := :new.responsableid;
    v_identificador_tarea := :new.tareaid;
    v_identificador_proyecto_tarea := :new.proyectoid;
    v_fecha_finalizacion_antigua := :old.fechafinalizacion;
    
    
  END BEFORE EACH ROW;

 AFTER EACH ROW IS
 
 BEGIN

select sysdate into v_fecha_cambio from dual;

-- Obtener el usuario de la sesión actual:

select SYS_CONTEXT ('USERENV', 'SESSION_USER') into v_nombre_usuario FROM DUAL;
   
 if v_estado_nuevo_tarea <> v_estado_antiguo_tarea then

  if v_estado_antiguo_tarea = 'Pendiente' then

      if v_estado_nuevo_tarea = 'En Progreso' then
      
      -- Insertar el cmabio de estado en el Historial de Tareas:
      
      insert into HistorialTareas (HistorialID, TareaID, EstadoAnterior, EstadoNuevo, FechaCambio, Usuario) 
      values (Historial_Tareas_seq.NEXTVAL, v_identificador_tarea, v_estado_antiguo_tarea, v_estado_nuevo_tarea, v_fecha_cambio, v_nombre_usuario);
    
        -- Asunto del correo electrónico
        DBMS_OUTPUT.PUT_LINE('Asunto: Actualización de cambio de estado de: "Pendiente" a "En Progreso"');
    
        -- Cuerpo del correo electrónico
        DBMS_OUTPUT.PUT_LINE('Estimado/a Usuario Responsable con Indentificador: ' || v_identificador_responsable || '.');
        DBMS_OUTPUT.PUT_LINE('');
        DBMS_OUTPUT.PUT_LINE('Informamos de que la tarea con identificador: ' || v_identificador_tarea || ' ha cambiado su estado a "En progreso".');
        DBMS_OUTPUT.PUT_LINE('');
        DBMS_OUTPUT.PUT_LINE('Gracias,');
        DBMS_OUTPUT.PUT_LINE('ATT: Samuel Hernández, Administrador.');
        
        else  
        
        if v_estado_nuevo_tarea = 'Completado' then
        RAISE_APPLICATION_ERROR(-20001, 'Transición de estado de ' || v_estado_antiguo_tarea || ' a ' || v_estado_nuevo_tarea || ' inconsistente.');
        
        end if;
    
      end if;

  elsif v_estado_antiguo_tarea  = 'En Progreso' then 
  
      if v_estado_nuevo_tarea = 'Completado' then
      
       insert into HistorialTareas (HistorialID, TareaID, EstadoAnterior, EstadoNuevo, FechaCambio, Usuario) 
      values (Historial_Tareas_seq.NEXTVAL, v_identificador_tarea, v_estado_antiguo_tarea, v_estado_nuevo_tarea, v_fecha_cambio, v_nombre_usuario);
        
          -- Asunto del correo electrónico
        DBMS_OUTPUT.PUT_LINE('Asunto: Actualización de cambio de estado de: "En Progreso" a "Completado"');
    
        -- Cuerpo del correo electrónico
        DBMS_OUTPUT.PUT_LINE('Estimado/a Usuario Responsable con Indentificador: ' || v_identificador_responsable || '.');
        DBMS_OUTPUT.PUT_LINE('');
        DBMS_OUTPUT.PUT_LINE('Informamos de que la tarea con identificador: ' || v_identificador_tarea || ' ha cambiado su estado a "Completado".');
        DBMS_OUTPUT.PUT_LINE('');
        DBMS_OUTPUT.PUT_LINE('Gracias,');
        DBMS_OUTPUT.PUT_LINE('ATT: Samuel Hernández, Administrador.');
        
        else
        
       if v_estado_nuevo_tarea = 'Pendiente' then 
       RAISE_APPLICATION_ERROR(-20002, 'Transición de estado de ' || v_estado_antiguo_tarea || ' a ' || v_estado_nuevo_tarea || ' inconsistente.');
       end if;
       end if;
  
  
  elsif v_estado_antiguo_tarea = 'Completado' then
  
    if v_estado_nuevo_tarea = 'En Progreso' or v_estado_nuevo_tarea = 'Pendiente' then
     RAISE_APPLICATION_ERROR(-20003, 'El estado de ' || v_estado_antiguo_tarea || ' no puede ser modificado a ningún otro estado distinto.');
     end if;
  
end if;

 else   
  RAISE_APPLICATION_ERROR(-20004, 'El estado de la tarea es el mismo.');

 end if;
 
 END AFTER EACH ROW;
 

END Estado_tareas_COMP_TRIGGER;


-- Procedimiento a integrar en el trigger para manejar el estado global del proyecto:

create or replace procedure Recorrer_tareas_proyectos(v_proyecto_id Tareas.proyectoid%type)
as
v_contador_estado_completado number := 0;
v_contador_estado_enprogreso number := 0;
v_contador_estado_pendiente  number := 0;

v_estado_completado BOOLEAN := FALSE;
v_estado_enprogreso BOOLEAN := FALSE;  
v_estado_pendiente BOOLEAN := FALSE;

v_total number := 0;


 cursor c_tareas IS
        SELECT estado
        FROM Tareas
        WHERE PROYECTOID = v_proyecto_id;
begin
  
  for tareas in c_tareas loop
    dbms_output.put_line('Estado: ' || tareas.estado);
    
    if tareas.estado = 'Completado' then 
    v_contador_estado_completado := v_contador_estado_completado + 1;

    elsif tareas.estado = 'En Progreso' then
     v_contador_estado_enprogreso := v_contador_estado_enprogreso + 1;
     
    elsif tareas.estado = 'Pendiente' then
     v_contador_estado_pendiente := v_contador_estado_pendiente + 1;
    end if;
    
end loop;

    v_total := v_contador_estado_completado + v_contador_estado_enprogreso + v_contador_estado_pendiente;



BEGIN
    CASE
        WHEN  v_contador_estado_completado = v_total THEN   
            v_estado_completado := TRUE;
            v_estado_enprogreso := FALSE;
            v_estado_pendiente := FALSE;
            
            DBMS_OUTPUT.PUT_LINE('El estado global para el Proyecto: ' || v_proyecto_id || ' es "Completado"');      
            
        WHEN v_contador_estado_enprogreso = v_total THEN
            v_estado_enprogreso := TRUE;
            v_estado_completado := FALSE;
            v_estado_pendiente := FALSE;
            
            DBMS_OUTPUT.PUT_LINE('El estado global para el Proyecto: ' || v_proyecto_id || ' es "En Progreso"');
            
         WHEN v_contador_estado_pendiente = v_total THEN
            v_estado_pendiente := TRUE;
            v_estado_completado := FALSE;
            v_estado_enprogreso := FALSE;
            
            DBMS_OUTPUT.PUT_LINE('El estado global para el Proyecto: ' || v_proyecto_id || ' es "Pendiente"'); 
            
        WHEN  v_contador_estado_enprogreso > 0 and v_contador_estado_completado > 0 THEN
            v_estado_enprogreso := TRUE;
            v_estado_completado := FALSE;
            v_estado_pendiente := FALSE;
            
            DBMS_OUTPUT.PUT_LINE('El estado global para el Proyecto: ' || v_proyecto_id || ' es "En Progreso"');
        
        WHEN  v_contador_estado_pendiente > 0 and v_contador_estado_completado > 0 THEN
            v_estado_enprogreso := TRUE;
            v_estado_completado := FALSE;
            v_estado_pendiente := FALSE;
            
            DBMS_OUTPUT.PUT_LINE('El estado global para el Proyecto: ' || v_proyecto_id || ' es "En Progreso"');
            
        WHEN  v_contador_estado_pendiente > 0 and v_contador_estado_enprogreso > 0 THEN
            v_estado_enprogreso := TRUE;
            v_estado_completado := FALSE;
            v_estado_pendiente := FALSE;
            
            DBMS_OUTPUT.PUT_LINE('El estado global para el Proyecto: ' || v_proyecto_id || ' es "En Progreso"');   
            
        WHEN  v_contador_estado_enprogreso > 0 and v_contador_estado_completado > 0 and v_contador_estado_pendiente > 0 THEN
            v_estado_enprogreso := TRUE;
            v_estado_completado := FALSE;
            v_estado_pendiente := FALSE;
            
            DBMS_OUTPUT.PUT_LINE('El estado global para el Proyecto: ' || v_proyecto_id || 'sigue siendo "En Progreso"');   
            
    END CASE;
    
     IF  v_estado_completado THEN  
     
     UPDATE Proyectos set estadoglobal = 'Completado'
     where proyectoid = v_proyecto_id;
    
     ELSIF v_estado_enprogreso THEN
     
      UPDATE Proyectos set estadoglobal = 'En Progreso'
     where proyectoid = v_proyecto_id;
     
     ELSIF v_estado_pendiente THEN
     
     UPDATE Proyectos set estadoglobal = 'Pendiente'
     where proyectoid = v_proyecto_id;
     
     END IF;

    
END;
    dbms_output.put_line('Identificador Proyecto: ' || v_proyecto_id || ' Tareas Completadas: ' || v_contador_estado_completado || ' En Progreso: ' || v_contador_estado_enprogreso || ' Pendientes: '|| v_contador_estado_pendiente || ' Tareas en Total: ' || v_total);
end;
/

-- Comprobar el estado global de los proyectos y las tareas:

select * from tareas;
select * from proyectos;

-- Llamada al procedimiento almacenado:

DECLARE
    p_id_proyecto Tareas.proyectoid%type := &proyecto;

BEGIN
    Recorrer_tareas_proyectos(p_id_proyecto);   
END;
/




