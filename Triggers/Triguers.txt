------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Tipo de Trigger	  :OLD Disponible	  :NEW Disponible		Descripción
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
BEFORE INSERT	     No		  		Sí			Se usa para modificar los datos antes de la inserción en la tabla.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
AFTER INSERT	     No				Sí			Se usa para realizar acciones después de la inserción, como auditoría o actualizaciones.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
BEFORE UPDATE	     Sí				Sí			Se usa para modificar datos antes de actualizar la fila. Puedes acceder a los valores anteriores y nuevos.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
AFTER UPDATE	     Sí				Sí			Se usa para realizar acciones después de la actualización. Puedes acceder a los valores anteriores y nuevos.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
BEFORE DELETE	     Sí				No			Se usa para modificar o validar datos antes de eliminar una fila. Solo puedes acceder a los valores anteriores.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
AFTER DELETE	     Sí				No			Se usa para realizar acciones después de la eliminación, como auditoría. Solo puedes acceder a los valores anteriores.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


-- 1 Trigger para actualizar el stock de productos después de insertar en la tabla de detallepedidos
     y verificar que no asigne valores negativos en caso de poner una cantidad mayor al stock disponible de productos.

create or replace trigger productos_actualizar_stock
after insert on detalle_pedido for each row
declare
c_p producto.cantidad_en_stock%TYPE;
begin

  update producto
  set cantidad_en_stock = cantidad_en_stock - :new.cantidad
  where codigo_producto = :new.codigo_producto;
  
  SELECT cantidad_en_stock into c_p FROM producto WHERE codigo_producto = :new.codigo_producto;
 
  if (c_p < 0) then
  update producto
  set cantidad_en_stock = 0
  where codigo_producto = :new.codigo_producto;  
  end if;
end;

-- Probar el primer update:

insert into detalle_pedido values (126,'OR-99', 50, 60,1);

select cantidad_en_stock from producto where codigo_producto = 'OR-99';

-- Probar el segundo update:

insert into detalle_pedido values (127,'OR-99', 100, 60,1);

select cantidad_en_stock from producto where codigo_producto = 'OR-99';


-- 2 Crear un trigger que actualice el stock de productos después de insertar un detalle en la tabla detalle_pedido, y registre los cambios en una tabla de auditoría.

CREATE TABLE auditoria_stock (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  codigo_producto VARCHAR2(50),
  cantidad_cambiada NUMBER,
  stock_anterior NUMBER,
  stock_nuevo NUMBER,
  fecha TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


create or replace trigger productos_actualizar_stock_2
after insert on detalle_pedido for each row
declare

cantidad_final producto.cantidad_en_stock%TYPE;
stock_producto_anterior producto.cantidad_en_stock%TYPE;
fecha_actual TIMESTAMP;


begin

-- Obtener el la cantidad en stock antigua:

  select cantidad_en_stock into stock_producto_anterior from producto
   where codigo_producto = :new.codigo_producto;

  update producto
  set cantidad_en_stock = cantidad_en_stock - :new.cantidad
  where codigo_producto = :new.codigo_producto;

-- Obtener el la cantidad en stock actual:

  SELECT cantidad_en_stock into cantidad_final FROM producto WHERE codigo_producto = :new.codigo_producto;
 
  if (cantidad_final < 0) then
  update producto
  set cantidad_en_stock = 0
  where codigo_producto = :new.codigo_producto;  
  end if;	

  select sysdate into fecha_actual from dual;

  insert into auditoria_stock values (1, :new.codigo_producto, :new.cantidad, stock_producto_anterior, cantidad_final, fecha_actual);
  
end;

-- Comprobación del funcionamiento del trigger:

select cantidad_en_stock from producto where codigo_producto = 'FR-67';

insert into detalle_pedido values (126,'OR-130', 100, 60,1);

select * from auditoria_stock;

-- 3 Crear un trigger en PL/SQL que se active antes de actualizar el precio de un producto. El trigger debe verificar si el nuevo precio es mayor que el precio anterior. 
     Si el nuevo precio es mayor, el trigger debe insertar un registro en una tabla de auditoría llamada auditoria_precios. Esta tabla de auditoría debe registrar la siguiente información:

- El código del producto (codigo_producto).
- El precio antiguo (precio_anterior).
- El nuevo precio (precio_nuevo).
- La fecha y hora del cambio (fecha_cambio).

CREATE TABLE auditoria_precios (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  codigo_producto VARCHAR2(50),
  precio_antiguo_producto NUMBER,
  precio_nuevo_producto NUMBER,
  fecha_cambio TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Crear secuencia incremental para el identificador de la tabla que audita los precios:

CREATE SEQUENCE auditoria_precios_
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

create or replace trigger antes_actualizar_precio_productos
before update on producto for each row
declare
codigo_producto_nuevo producto.codigo_producto%TYPE;
precio_antiguo producto.precio_v%TYPE;
precio_nuevo producto.precio_v%TYPE;
fecha_cambio TIMESTAMP;
begin 

precio_nuevo := :new.precio_v;
precio_antiguo := :old.precio_v;
codigo_producto_nuevo := :new.codigo_producto;

select sysdate into fecha_cambio from dual;

if precio_nuevo > precio_antiguo then
insert into auditoria_precios VALUES (auditoria_precios_.NEXTVAL, codigo_producto_nuevo, precio_antiguo, precio_nuevo, fecha_cambio);
else
if precio_nuevo = precio_antiguo then
RAISE_APPLICATION_ERROR(-20001, 'El nuevo precio es igual al precio antiguo. No se permite actualizar con el mismo valor.');
end if;
end if;

end;

-- Comprobación de funcionamiento.

update producto
set precio_v = precio_v + 20
where codigo_producto = 'OR-250';


SELECT * FROM auditoria_precios;

-- 4


