 ¿Qué son los disparadores compuestos o COMPOUND TRIGGERS?

- Los Disparadores Compuestos o Compound Triggers, son una nueva herramienta para apoyar en la codificación reducida y la interactividad entre objetos en base de datos.

¿Cuáles son las cada una de sus secciones?

1. BEFORE STATEMENT y AFTER STATEMENT:

- Estas secciones se ejecutan una sola vez, antes o después de todas las operaciones DML (INSERT, UPDATE, DELETE).

¿Cuándo Usar?:

- BEFORE STATEMENT: Para inicializar variables o realizar acciones que deben ejecutarse una vez antes de que se procesen todas las filas afectadas por la transacción.
- AFTER STATEMENT: Para realizar acciones después de que todas las filas han sido procesadas, como registrar una acción de auditoría o realizar limpieza.

2. BEFORE EACH ROW y AFTER EACH ROW:

- Estas secciones se ejecutan una vez para cada fila afectada por la operación DML.

¿Cuándo Usar?:

BEFORE EACH ROW: Para preparar o modificar datos antes de que se realicen las operaciones en la base de datos. Ideal para validar o modificar valores de una fila antes de que se inserten o actualicen en la tabla.
AFTER EACH ROW: Para realizar acciones después de que se ha procesado cada fila, como registrar cambios en una tabla de auditoría para cada fila afectada.


-----------------------------
Ejercicios de introducción:
-----------------------------

-- 1 

CREATE OR REPLACE TRIGGER trig1_before_st BEFORE
 INSERT OR UPDATE OR DELETE ON emp
 BEGIN
 dbms_output.put_line('BEFORE STATEMENT TRIGGER');
 END;
/
CREATE OR REPLACE TRIGGER trig1_before_rw BEFORE
 INSERT OR UPDATE OR DELETE ON emp
 FOR EACH ROW
 BEGIN
 dbms_output.put_line('BEFORE ROW TRIGGER');
 END;
/
CREATE OR REPLACE TRIGGER trig2_after_st AFTER
 INSERT OR UPDATE OR DELETE ON emp
 BEGIN
 dbms_output.put_line('BEFORE STATEMENT TRIGGER');
 END;
/
CREATE OR REPLACE TRIGGER trig2_after_rw AFTER
 INSERT OR UPDATE OR DELETE ON emp
 FOR EACH ROW
 BEGIN
 dbms_output.put_line('AFTER ROW TRIGGER');
 END;

-- Activación del trigger:

 insert into emp values (1,'Samuel',1000,102);


-- 2 Los 4 tipos de triggers anteriores se pueden combinar en un solo trigger:


CREATE OR REPLACE TRIGGER EMP_COMP_TRIGGER
FOR INSERT OR UPDATE OR DELETE ON emp COMPOUND TRIGGER

-- Variables globales
variable_global VARCHAR2(50):= ' DEMO ON COMPOUND TRIGGER ';

BEFORE STATEMENT IS
-- Variables de declaración
l_variable VARCHAR2(50) := ' BEFORE STATEMENT TRIGGER ';
BEGIN
-- Acciones BEFORE STATEMENT
dbms_output.put_line(l_variable||variable_global);
END BEFORE STATEMENT;


BEFORE EACH ROW IS
-- Variables de declaración
l_variable VARCHAR2(50) := ' BEFORE EACH ROW TRIGGER ';
BEGIN
-- Acciones BEFORE EACH ROW
dbms_output.put_line(l_variable||variable_global);
END BEFORE EACH ROW;


AFTER EACH ROW IS
-- Variables de declaración
l_variable VARCHAR2(50) := ' AFTER EACH ROW TRIGGER ';
BEGIN
-- Acciones AFTER EACH
dbms_output.put_line(l_variable||variable_global);
END AFTER EACH ROW;


AFTER STATEMENT IS
-- Variables de declaración
l_variable VARCHAR2(50) := ' AFTER STATEMENT TRIGGER ';
BEGIN
-- After statement section
dbms_output.put_line(l_variable||variable_global);
END AFTER STATEMENT;

END emp_comp_trigger;
/

-- Activación del trigger:

update emp
set salario = salario + 1000
where empleado_id = 1;
where empleado_id = 1;


-- 3 Se pueden especificar los 3 tipos de operaciones (INSERTING, UPDATING, DELETING).

CREATE OR REPLACE TRIGGER EMP_COMP_TRIGGER
FOR INSERT OR UPDATE OR DELETE ON emp COMPOUND TRIGGER

-- Variables globales
variable_global VARCHAR2(50):= ' DEMO ON COMPOUND TRIGGER ';

BEFORE STATEMENT IS
l_variable VARCHAR2(50) := ' BEFORE STATEMENT ';
BEGIN

IF INSERTING THEN
dbms_output.put_line(l_variable || variable_global || ' INSERT');

ELSIF UPDATING THEN
dbms_output.put_line(l_variable || variable_global || ' UPDATE');

ELSIF DELETING THEN
dbms_output.put_line(l_variable || variable_global || ' DELETE');

END IF;
END BEFORE STATEMENT;

END emp_comp_trigger;
/

-- Activación del trigger:

insert into emp values (5,'Manolo',1000,102);

update emp
set salario = salario + 1000
where empleado_id = 1;
where empleado_id = 1;

delete from emp
where empleado_id = 5;

-- 4 Capturar previamente mediante un "BEFORE" cada una de las 3 operaciones de insercción, actualización o borrado, y registrarlas despues fila por fila con un "AFTER", en una tabla que 
     audite dicha información:

CREATE SEQUENCE auditoria_empleados_acciones
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

CREATE TABLE Auditoria_Empleados_Acciones (
    AuditID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    EmpID NUMBER,
    Accion VARCHAR2(10),
    Fecha TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE OR REPLACE TRIGGER trg_AuditoriaEmpleados
COMPOUND TRIGGER

    -- Sección de declaración de variables:

    v_empid Empleados.EmpID%TYPE;
    v_accion VARCHAR2(10);

    -- Acción a realizar antes de la inserción:

    BEFORE INSERT ON Empleados
    FOR EACH ROW
    BEGIN
        v_empid := :NEW.EmpID;
        v_accion := 'INSERT';
    END BEFORE INSERT;

    -- Acción a realizar antes de la actualización:

    BEFORE UPDATE ON Empleados
    FOR EACH ROW
    BEGIN
        v_empid := :NEW.EmpID;
        v_accion := 'UPDATE';
    END BEFORE UPDATE;

    -- Acción a realizar antes de la eliminación:

    BEFORE DELETE ON Empleados
    FOR EACH ROW
    BEGIN
        v_empid := :OLD.EmpID;
        v_accion := 'DELETE';
    END BEFORE DELETE;

    -- Acción a realizar después de todas las operaciones:

    AFTER EACH ROW
    BEGIN
        INSERT INTO Auditoria_Empleados_Acciones (EmpID, Accion)
        VALUES (v_empid, v_accion);
    END AFTER EACH ROW;

END trg_AuditoriaEmpleados;

-- 5 Trigger compuesto que se active al realizar operaciones de inserción, actualización o borrado sobre la tabla 'cli' y auditar en 'AuditoriaClientes' información
-- correspondiente a cada cliente en función de si se inserta, actualiza o borra. Hacer uso del condicional 'IF', y sentencia 'INSERT INTO' para cada caso.

CREATE TABLE Cli (
    ClienteID NUMBER PRIMARY KEY,
    Nombre VARCHAR2(100),
    Direccion VARCHAR2(255)
);

CREATE TABLE AuditoriaClientes (
    AuditoriaID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    ClienteID NUMBER,
    Nombre VARCHAR2(100),
    Direccion VARCHAR2(255),
    Accion VARCHAR2(10),
    Fecha TIMESTAMP
);
/

CREATE SEQUENCE auditoria_CLI
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;
/

CREATE OR REPLACE TRIGGER CLI_COMP_TRIGGER
FOR INSERT OR UPDATE OR DELETE ON cli COMPOUND TRIGGER

  -- Variable global
  v_fecha TIMESTAMP;

  -- Sección BEFORE STATEMENT
  BEFORE STATEMENT IS
  BEGIN
    v_fecha := SYSDATE;
  END BEFORE STATEMENT;

  -- Sección BEFORE EACH ROW
  BEFORE EACH ROW IS
  l_variable VARCHAR2(50) := 'Procesando fila de la tabla Clientes...';
  BEGIN
    -- Esta sección está vacía en este caso, pero debe estar correctamente delimitada
    dbms_output.put_line('-' || l_variable);
  END BEFORE EACH ROW;

  -- Sección AFTER EACH ROW
  AFTER EACH ROW IS
  BEGIN
    IF INSERTING THEN
      INSERT INTO AuditoriaClientes (AuditoriaID, ClienteID, Nombre, Direccion, Accion, Fecha)
      VALUES (auditoria_CLI.NEXTVAL, :NEW.ClienteID, :NEW.Nombre, :NEW.Direccion, 'INSERT', v_fecha);

    ELSIF UPDATING THEN
      INSERT INTO AuditoriaClientes (AuditoriaID, ClienteID, Nombre, Direccion, Accion, Fecha)
      VALUES (auditoria_CLI.NEXTVAL, :NEW.ClienteID, :NEW.Nombre, :NEW.Direccion, 'UPDATE', v_fecha);

    ELSIF DELETING THEN
      INSERT INTO AuditoriaClientes (AuditoriaID, ClienteID, Nombre, Direccion, Accion, Fecha)
      VALUES (auditoria_CLI.NEXTVAL, :OLD.ClienteID, :OLD.Nombre, :OLD.Direccion, 'DELETE', v_fecha);
    END IF;
  END AFTER EACH ROW;

END CLI_COMP_TRIGGER;
/

-- Activación del Trigger:

INSERT INTO ClI(ClienteID, Nombre, Direccion) VALUES (13, 'Manuel', 'Calle Nicaragua, Madrid');

-- Comprobación dela auditación:

select * from AuditoriaClientes;

-- Creación de un Trigger compuesto para la sincronización de datos entre 2 tablas; 'Emps' y 'Deps' (Empleados y Departamentos). 
-- Usando las sección 'BEFORE EACH ROW' para capturar el 'DepartamentoID' antiguo y nuevo, y la sección 'AFTER EACH ROW' para las operaciones que detallo a continuación: 

-- Haciendo uso del condicional 'IF': 
-- En la primera condición de inserción actualizar la tabla 'Deps', incrementando en 1 el campo 'NumeroEmpleados' del nuevo departamento insertado.
-- En la segunda condición de actualización, hacer uso de 2 updates, el primero para decrementar en 1 el campo 'NumeroEmpleados' de la tabla 'Deps' del antiguo departamento, y el segundo para incrementarlo en el nuevo 
  departamento.
-- En la ultima condición de borrado, actualizar la tabla 'Deps', para decrementar en 1 el campo 'NumeroEmpleados' de la tabla 'Deps' del antiguo departamento al que pertenecía.

 CREATE OR REPLACE TRIGGER Emps_Deps_sincronización_COMP_TRIGGER
FOR INSERT OR UPDATE OR DELETE ON Emps COMPOUND TRIGGER

  BEFORE EACH ROW IS
  v_departamentoId_antiguo Emps.DepartamentoID%TYPE;
  v_departamentoId_nuevo   Emps.DepartamentoID%TYPE;
  
  BEGIN
    v_departamentoId_antiguo := :old.DepartamentoID;
    v_departamentoId_nuevo := :new.DepartamentoID;
  END BEFORE EACH ROW;

  AFTER EACH ROW IS

  BEGIN
    IF INSERTING THEN
    
    update Deps
    set NumeroEmpleados = NumeroEmpleados + 1
    where DepartamentoID = :NEW.DepartamentoID;

    ELSIF UPDATING THEN
      
    update Deps
    set NumeroEmpleados = NumeroEmpleados - 1
    where DepartamentoID = :OLD.DepartamentoID;
    
    update Deps
    set NumeroEmpleados = NumeroEmpleados + 1
    where DepartamentoID = :NEW.DepartamentoID;


    ELSIF DELETING THEN
    
    update Deps
    set NumeroEmpleados = NumeroEmpleados - 1
    where DepartamentoID = :OLD.DepartamentoID;
    
    END IF;
  END AFTER EACH ROW;

END Emps_Deps_sincronización_COMP_TRIGGER;
/

-- Activación del Trigger:

-- Inserción:

INSERT INTO  Emps (EmpleadoID,Nombre,DepartamentoID,FechaContratacion) VALUES (104, 'Samuel Hernández', 1, '15/08/24');

-- Actualización:

update Emps 
set DepartamentoID = 2
where EmpleadoID = 104;

-- Borrado:

delete Emps
where EmpleadoID = 104;







