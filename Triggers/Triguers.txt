------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Tipo de Trigger	  :OLD Disponible	  :NEW Disponible		Descripción
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
BEFORE INSERT	     No		  		Sí			Se usa para modificar los datos antes de la inserción en la tabla.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
AFTER INSERT	     No				Sí			Se usa para realizar acciones después de la inserción, como auditoría o actualizaciones.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
BEFORE UPDATE	     Sí				Sí			Se usa para modificar datos antes de actualizar la fila. Puedes acceder a los valores anteriores y nuevos.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
AFTER UPDATE	     Sí				Sí			Se usa para realizar acciones después de la actualización. Puedes acceder a los valores anteriores y nuevos.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
BEFORE DELETE	     Sí				No			Se usa para modificar o validar datos antes de eliminar una fila. Solo puedes acceder a los valores anteriores.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
AFTER DELETE	     Sí				No			Se usa para realizar acciones después de la eliminación, como auditoría. Solo puedes acceder a los valores anteriores.
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


-- 1 Trigger para actualizar el stock de productos después de insertar en la tabla de detallepedidos
     y verificar que no asigne valores negativos en caso de poner una cantidad mayor al stock disponible de productos.

create or replace trigger productos_actualizar_stock
after insert on detalle_pedido for each row
declare
c_p producto.cantidad_en_stock%TYPE;
begin

  update producto
  set cantidad_en_stock = cantidad_en_stock - :new.cantidad
  where codigo_producto = :new.codigo_producto;
  
  SELECT cantidad_en_stock into c_p FROM producto WHERE codigo_producto = :new.codigo_producto;
 
  if (c_p < 0) then
  update producto
  set cantidad_en_stock = 0
  where codigo_producto = :new.codigo_producto;  
  end if;
end;

-- Probar el primer update:

insert into detalle_pedido values (126,'OR-99', 50, 60,1);

select cantidad_en_stock from producto where codigo_producto = 'OR-99';

-- Probar el segundo update:

insert into detalle_pedido values (127,'OR-99', 100, 60,1);

select cantidad_en_stock from producto where codigo_producto = 'OR-99';


-- 2 Crear un trigger que actualice el stock de productos después de insertar un detalle en la tabla detalle_pedido, y registre los cambios en una tabla de auditoría.

CREATE TABLE auditoria_stock (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  codigo_producto VARCHAR2(50),
  cantidad_cambiada NUMBER,
  stock_anterior NUMBER,
  stock_nuevo NUMBER,
  fecha TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);


create or replace trigger productos_actualizar_stock_2
after insert on detalle_pedido for each row
declare

cantidad_final producto.cantidad_en_stock%TYPE;
stock_producto_anterior producto.cantidad_en_stock%TYPE;
fecha_actual TIMESTAMP;


begin

-- Obtener el la cantidad en stock antigua:

  select cantidad_en_stock into stock_producto_anterior from producto
   where codigo_producto = :new.codigo_producto;

  update producto
  set cantidad_en_stock = cantidad_en_stock - :new.cantidad
  where codigo_producto = :new.codigo_producto;

-- Obtener el la cantidad en stock actual:

  SELECT cantidad_en_stock into cantidad_final FROM producto WHERE codigo_producto = :new.codigo_producto;
 
  if (cantidad_final < 0) then
  update producto
  set cantidad_en_stock = 0
  where codigo_producto = :new.codigo_producto;  
  end if;	

  select sysdate into fecha_actual from dual;

  insert into auditoria_stock values (1, :new.codigo_producto, :new.cantidad, stock_producto_anterior, cantidad_final, fecha_actual);
  
end;

-- Comprobación del funcionamiento del trigger:

select cantidad_en_stock from producto where codigo_producto = 'FR-67';

insert into detalle_pedido values (126,'OR-130', 100, 60,1);

select * from auditoria_stock;

-- 3 Crear un trigger en PL/SQL que se active antes de actualizar el precio de un producto. El trigger debe verificar si el nuevo precio es mayor que el precio anterior. 
     Si el nuevo precio es mayor, el trigger debe insertar un registro en una tabla de auditoría llamada auditoria_precios. Esta tabla de auditoría debe registrar la siguiente información:

- El código del producto (codigo_producto).
- El precio antiguo (precio_anterior).
- El nuevo precio (precio_nuevo).
- La fecha y hora del cambio (fecha_cambio).

CREATE TABLE auditoria_precios (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  codigo_producto VARCHAR2(50),
  precio_antiguo_producto NUMBER,
  precio_nuevo_producto NUMBER,
  fecha_cambio TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Crear secuencia incremental para el identificador de la tabla que audita los precios:

CREATE SEQUENCE auditoria_precios_
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

create or replace trigger antes_actualizar_precio_productos
before update on producto for each row
declare
codigo_producto_nuevo producto.codigo_producto%TYPE;
precio_antiguo producto.precio_v%TYPE;
precio_nuevo producto.precio_v%TYPE;
fecha_cambio TIMESTAMP;
begin 

precio_nuevo := :new.precio_v;
precio_antiguo := :old.precio_v;
codigo_producto_nuevo := :new.codigo_producto;

select sysdate into fecha_cambio from dual;

if precio_nuevo > precio_antiguo then
insert into auditoria_precios VALUES (auditoria_precios_.NEXTVAL, codigo_producto_nuevo, precio_antiguo, precio_nuevo, fecha_cambio);
else
if precio_nuevo = precio_antiguo then
RAISE_APPLICATION_ERROR(-20001, 'El nuevo precio es igual al precio antiguo. No se permite actualizar con el mismo valor.');
end if;
end if;

end;

-- Comprobación de funcionamiento.

update producto
set precio_v = precio_v + 20
where codigo_producto = 'OR-250';


SELECT * FROM auditoria_precios;

-- 4 Crear un trigger en PL/SQL que registre los incrementos salariales en la tabla "incrementos_salario" cada vez que se actualice el salario de un empleado en la tabla empleados.

Trigger: Debe ser activado antes de actualizar el salario en la tabla empleados.
Acciones del Trigger:

- Registra el salario anterior y el nuevo salario en la tabla incrementos_salario.
- Incluye el nombre del departamento del empleado en el registro de la tabla incrementos_salario, obteniéndolo de la tabla departamentos.
 Inserta un registro con la información del empleado, el salario antes del incremento, el salario después del incremento, la fecha del incremento y el nombre del departamento.

-- Solución: 

Da error de "tabla mutada" al estar realizando un operación sobre la misma tabla que esta tratando el trigger
ya que el ejercicio propuesto en si es problemático, sin embargo, propongo la solución alternativa de sacar los datos a traves de una tabla permanente que los obtiene mediante
un procedimiento almacenado, que adicionalmente trata las redundancias de los datos (duplicados). (Podría proponerse también otra solución empleando "COMPOUND TRIGGERS").


CREATE SEQUENCE nombre_departamentos_seq
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

CREATE SEQUENCE auditoria_empleados_
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

CREATE TABLE tabla_intermedia (
  id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  empleado_id NUMBER,
  departamento_id NUMBER,
  nombre_del_departamento VARCHAR2(50)
  
);


-- Procedimiento almacenado que obtiene ciertos datos de empleados y departamentos, cuidando las redundancias, y los guarda en otra tabla accesible desde el trigger:

CREATE OR REPLACE PROCEDURE Backup_empleado_departamento
AS
registro number(25);
tabla_vacia_llena number(8);
registros_duplicados number(8);

cursor datos_dep_emp is 
SELECT e.empleado_id as empleadoid, d.departamento_id as departamentoid, d.nombre_departamento as nombredepartamento
FROM empleados e JOIN departamentos d ON e.departamento_id = d.departamento_id;
BEGIN

SELECT count(*) into tabla_vacia_llena FROM tabla_intermedia;

SELECT COUNT(*)
INTO registros_duplicados
FROM (
  SELECT empleado_id, departamento_id, nombre_del_departamento
  FROM tabla_intermedia
  GROUP BY empleado_id, departamento_id, nombre_del_departamento
  HAVING COUNT(*) > 1
);

if tabla_vacia_llena > 0 then 

if registros_duplicados > 0  then
  DELETE FROM tabla_intermedia
  where id not in (SELECT MIN(id) FROM  tabla_intermedia GROUP BY empleado_id, departamento_id, nombre_del_departamento); <-- Condición de borrado que garantiza borrar solo registros redundantes.
end if;

else
  for registro in datos_dep_emp loop
  INSERT INTO tabla_intermedia values (nombre_departamentos_seq.NEXTVAL, registro.empleadoid, registro.departamentoid, registro.nombredepartamento);
 end loop;  
 
end if;

END;
/

BEGIN
     Backup_empleado_departamento;
END;
/

create or replace trigger incrementos_salariales
after update on empleados for each row
declare
salario_anterior empleados.salario%TYPE;
salario_nuevo empleados.salario%TYPE;
v_nombre_departamento departamentos.nombre_departamento%TYPE;
identificador_empleado empleados.empleado_id%TYPE;
identificador_departamento departamentos.departamento_id%TYPE;
fecha_incremento TIMESTAMP;

begin

 salario_anterior := :old.salario;
 salario_nuevo := :new.salario;
 identificador_departamento := :new.departamento_id;
 identificador_empleado := :new.empleado_id;
 

 select nombre_del_departamento into v_nombre_departamento from tabla_intermedia t
 WHERE t.empleado_id = identificador_empleado; 

 select sysdate into fecha_incremento from dual;

  INSERT INTO incrementos_salario values (auditoria_empleados_.NEXTVAL, identificador_empleado, salario_anterior, salario_nuevo, fecha_incremento, v_nombre_departamento);

end;

-- Activación del trigger:

update empleados
set salario = salario + 1
where empleado_id = 2;
