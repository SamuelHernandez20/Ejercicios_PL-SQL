 ¿Qué son los disparadores compuestos o COMPOUND TRIGGERS?

- Los Disparadores Compuestos o Compound Triggers, son una nueva herramienta para apoyar en la codificación reducida y la interactividad entre objetos en base de datos.

¿Cuáles son las cada una de sus secciones?

1. BEFORE STATEMENT y AFTER STATEMENT:

- Estas secciones se ejecutan una sola vez, antes o después de todas las operaciones DML (INSERT, UPDATE, DELETE).

¿Cuándo Usar?:

- BEFORE STATEMENT: Para inicializar variables o realizar acciones que deben ejecutarse una vez antes de que se procesen todas las filas afectadas por la transacción.
- AFTER STATEMENT: Para realizar acciones después de que todas las filas han sido procesadas, como registrar una acción de auditoría o realizar limpieza.

2. BEFORE EACH ROW y AFTER EACH ROW:

- Estas secciones se ejecutan una vez para cada fila afectada por la operación DML.

¿Cuándo Usar?:

BEFORE EACH ROW: Para preparar o modificar datos antes de que se realicen las operaciones en la base de datos. Ideal para validar o modificar valores de una fila antes de que se inserten o actualicen en la tabla.
AFTER EACH ROW: Para realizar acciones después de que se ha procesado cada fila, como registrar cambios en una tabla de auditoría para cada fila afectada.


-----------------------------
Ejercicios de introducción:
-----------------------------

-- 1 

CREATE OR REPLACE TRIGGER trig1_before_st BEFORE
 INSERT OR UPDATE OR DELETE ON emp
 BEGIN
 dbms_output.put_line('BEFORE STATEMENT TRIGGER');
 END;
/
CREATE OR REPLACE TRIGGER trig1_before_rw BEFORE
 INSERT OR UPDATE OR DELETE ON emp
 FOR EACH ROW
 BEGIN
 dbms_output.put_line('BEFORE ROW TRIGGER');
 END;
/
CREATE OR REPLACE TRIGGER trig2_after_st AFTER
 INSERT OR UPDATE OR DELETE ON emp
 BEGIN
 dbms_output.put_line('BEFORE STATEMENT TRIGGER');
 END;
/
CREATE OR REPLACE TRIGGER trig2_after_rw AFTER
 INSERT OR UPDATE OR DELETE ON emp
 FOR EACH ROW
 BEGIN
 dbms_output.put_line('AFTER ROW TRIGGER');
 END;

-- Activación del trigger:

 insert into emp values (1,'Samuel',1000,102);


-- 2 Los 4 tipos de triggers anteriores se pueden combinar en un solo trigger:


CREATE OR REPLACE TRIGGER EMP_COMP_TRIGGER
FOR INSERT OR UPDATE OR DELETE ON emp COMPOUND TRIGGER

-- Variables globales
variable_global VARCHAR2(50):= ' DEMO ON COMPOUND TRIGGER ';

BEFORE STATEMENT IS
-- Variables de declaración
l_variable VARCHAR2(50) := ' BEFORE STATEMENT TRIGGER ';
BEGIN
-- Acciones BEFORE STATEMENT
dbms_output.put_line(l_variable||variable_global);
END BEFORE STATEMENT;


BEFORE EACH ROW IS
-- Variables de declaración
l_variable VARCHAR2(50) := ' BEFORE EACH ROW TRIGGER ';
BEGIN
-- Acciones BEFORE EACH ROW
dbms_output.put_line(l_variable||variable_global);
END BEFORE EACH ROW;


AFTER EACH ROW IS
-- Variables de declaración
l_variable VARCHAR2(50) := ' AFTER EACH ROW TRIGGER ';
BEGIN
-- Acciones AFTER EACH
dbms_output.put_line(l_variable||variable_global);
END AFTER EACH ROW;


AFTER STATEMENT IS
-- Variables de declaración
l_variable VARCHAR2(50) := ' AFTER STATEMENT TRIGGER ';
BEGIN
-- After statement section
dbms_output.put_line(l_variable||variable_global);
END AFTER STATEMENT;

END emp_comp_trigger;
/

-- Activación del trigger:

update emp
set salario = salario + 1000
where empleado_id = 1;
where empleado_id = 1;


-- 3 Se pueden especificar los 3 tipos de operaciones (INSERTING, UPDATING, DELETING).

CREATE OR REPLACE TRIGGER EMP_COMP_TRIGGER
FOR INSERT OR UPDATE OR DELETE ON emp COMPOUND TRIGGER

-- Variables globales
variable_global VARCHAR2(50):= ' DEMO ON COMPOUND TRIGGER ';

BEFORE STATEMENT IS
l_variable VARCHAR2(50) := ' BEFORE STATEMENT ';
BEGIN

IF INSERTING THEN
dbms_output.put_line(l_variable || variable_global || ' INSERT');

ELSIF UPDATING THEN
dbms_output.put_line(l_variable || variable_global || ' UPDATE');

ELSIF DELETING THEN
dbms_output.put_line(l_variable || variable_global || ' DELETE');

END IF;
END BEFORE STATEMENT;

END emp_comp_trigger;
/

-- Activación del trigger:

insert into emp values (5,'Manolo',1000,102);

update emp
set salario = salario + 1000
where empleado_id = 1;
where empleado_id = 1;

delete from emp
where empleado_id = 5;

-- 4 Capturar previamente mediante un "BEFORE" cada una de las 3 operaciones de insercción, actualización o borrado, y registrarlas despues fila por fila con un "AFTER", en una tabla que 
     audite dicha información:

CREATE SEQUENCE auditoria_empleados_acciones
START WITH 1
INCREMENT BY 1
NOCACHE
NOCYCLE;

CREATE TABLE Auditoria_Empleados_Acciones (
    AuditID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    EmpID NUMBER,
    Accion VARCHAR2(10),
    Fecha TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE OR REPLACE TRIGGER trg_AuditoriaEmpleados
COMPOUND TRIGGER

    -- Sección de declaración de variables:

    v_empid Empleados.EmpID%TYPE;
    v_accion VARCHAR2(10);

    -- Acción a realizar antes de la inserción:

    BEFORE INSERT ON Empleados
    FOR EACH ROW
    BEGIN
        v_empid := :NEW.EmpID;
        v_accion := 'INSERT';
    END BEFORE INSERT;

    -- Acción a realizar antes de la actualización:

    BEFORE UPDATE ON Empleados
    FOR EACH ROW
    BEGIN
        v_empid := :NEW.EmpID;
        v_accion := 'UPDATE';
    END BEFORE UPDATE;

    -- Acción a realizar antes de la eliminación:

    BEFORE DELETE ON Empleados
    FOR EACH ROW
    BEGIN
        v_empid := :OLD.EmpID;
        v_accion := 'DELETE';
    END BEFORE DELETE;

    -- Acción a realizar después de todas las operaciones:

    AFTER EACH ROW
    BEGIN
        INSERT INTO Auditoria_Empleados_Acciones (EmpID, Accion)
        VALUES (v_empid, v_accion);
    END AFTER EACH ROW;

END trg_AuditoriaEmpleados;








